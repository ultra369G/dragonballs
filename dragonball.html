<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Previous head content remains the same -->
    <style>
        /* Add this to existing styles */
        #device-list {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Previous HTML remains the same -->
    <div id="device-list">Connected devices: 1</div>

    <script>
        // ====== ENHANCED CROSS-DEVICE COMMUNICATION ======
        const DEVICE_MAX_DISTANCE = 40; // Virtual 40cm threshold
        
        // Improved device connection
        function setupConnection() {
            // Try BroadcastChannel first
            try {
                connectionChannel = new BroadcastChannel('cosmic_orb_xdevice');
                connectionChannel.onmessage = handleMessage;
                
                // Fallback to localStorage if BroadcastChannel fails
                window.addEventListener('storage', (e) => {
                    if (e.key === 'cosmic_orb_msg') {
                        handleMessage({ data: JSON.parse(e.newValue) });
                    }
                });
                
                broadcastState();
            } catch (e) {
                console.error("Connection error:", e);
                updateStatus("‚ö†Ô∏è Using limited connection");
            }
        }

        // Enhanced message handling
        function handleMessage(event) {
            const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
            
            // Calculate virtual distance
            data.virtualDist = Math.sqrt(
                Math.pow(data.screenX - orb.screenX, 2) + 
                Math.pow(data.screenY - orb.screenY, 2)
            ) / 96; // Convert pixels to cm (approx)
            
            // Only process if within virtual 40cm
            if (data.virtualDist <= DEVICE_MAX_DISTANCE || data.id === orb.targetOrb?.id) {
                processOrbData(data);
            }
            
            updateDeviceList();
        }

        function updateDeviceList() {
            const activeDevices = otherOrbs.filter(o => 
                Date.now() - o.timestamp < 3000
            ).length + 1;
            document.getElementById('device-list').textContent = 
                `Connected devices: ${activeDevices}`;
        }

        // Enhanced broadcasting with fallback
        function broadcastState() {
            const message = {
                // Previous message properties plus:
                deviceType: getDeviceType(),
                virtualDist: 0,
                timestamp: Date.now()
            };
            
            try {
                connectionChannel.postMessage(message);
                // Fallback to localStorage
                localStorage.setItem('cosmic_orb_msg', JSON.stringify(message));
                localStorage.removeItem('cosmic_orb_msg');
            } catch (e) {
                console.log("Using fallback communication");
            }
        }

        function getDeviceType() {
            const ua = navigator.userAgent;
            if (/Mobile|Android|iPhone|iPad|iPod/i.test(ua)) return 'Mobile';
            if (/Windows/i.test(ua)) return 'Windows PC';
            if (/Macintosh|Mac OS X/i.test(ua)) return 'Mac';
            return 'Unknown';
        }

        // ====== DISTANCE-BASED MERGING ======
        function checkMerge() {
            // Only consider orbs within virtual 40cm
            const nearbyOrbs = otherOrbs.filter(o => o.virtualDist <= DEVICE_MAX_DISTANCE);
            
            if (nearbyOrbs.length === 0) return;
            
            // Find oldest nearby orb
            const oldestOrb = [...nearbyOrbs, orb].reduce((oldest, o) => 
                o.birthTime < oldest.birthTime ? o : oldest);
            
            if (oldestOrb.id === orb.id) {
                orb.state = 'attracting';
                orb.isSupreme = true;
                updateStatus("üåÄ Becoming cosmic anchor...");
            } else {
                orb.state = 'attracting';
                orb.targetOrb = oldestOrb;
                updateStatus(`üåÄ Drawn to ${oldestOrb.deviceType || 'another device'}`);
            }
            broadcastState();
        }

        // ====== REST OF THE CODE REMAINS THE SAME ======
        // (Previous orb logic, rendering, etc.)
    </script>
</body>
</html>
